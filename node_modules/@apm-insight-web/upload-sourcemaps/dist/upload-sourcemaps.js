"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UploadSourcemapsCommand = void 0;
const tslib_1 = require("tslib");
// https://code.byted.org/appmonitor/rangers_monitor_api_idl/blob/master/webview/mapping/mapping.thrift
const fs_1 = (0, tslib_1.__importDefault)(require("fs"));
const path_1 = (0, tslib_1.__importDefault)(require("path"));
const util_1 = require("util");
const axios_1 = (0, tslib_1.__importDefault)(require("axios"));
const chalk_1 = (0, tslib_1.__importDefault)(require("chalk"));
const clipanion_1 = require("clipanion");
const md5_1 = require("ts-md5/dist/md5");
const constants_cn_1 = require("./constants.cn");
const URI = '/apmplus_api/eue/guest/webpro/sourcemap/upload';
const HOST = constants_cn_1.CN_HOST;
const DEFAULT_RELEASE = '';
const DEFAULT_ENV = 'production';
const readdirAsync = (0, util_1.promisify)(fs_1.default.readdir);
const consoleReporter = {
    warning(msg) {
        process.stderr.write(`${chalk_1.default.yellow('warning')} ${msg}\n`);
    },
    info(msg) {
        process.stdout.write(`${chalk_1.default.blue('info')} ${msg}\n`);
    },
    error(msg) {
        process.stdout.write(`${chalk_1.default.red('error')} ${msg}\n`);
    },
};
class UploadSourcemapsCommand extends clipanion_1.Command {
    constructor() {
        super(...arguments);
        this.host = clipanion_1.Option.String(`--host`);
        this.release = clipanion_1.Option.String(`--release`);
        this.env = clipanion_1.Option.String(`--env`);
        this.app_id = clipanion_1.Option.String(`--app_id`);
        this._paths = clipanion_1.Option.Array(`--paths`);
        this.appSecret = clipanion_1.Option.String(`--app_secret`);
        this.appKey = clipanion_1.Option.String(`--app_key`);
    }
    static upload({ paths, app_id, host = HOST, env = DEFAULT_ENV, release = DEFAULT_RELEASE, appSecret, appKey, }) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            for (const dir of paths) {
                yield this.uploadDir({ dir: this.getPath(dir), app_id, host, env, release, appSecret, appKey });
            }
        });
    }
    static getPath(p) {
        if (path_1.default.isAbsolute(p)) {
            return p;
        }
        else {
            return path_1.default.join(process.cwd(), p);
        }
    }
    static uploadDir({ dir, app_id, host, env, release, appSecret, appKey, }) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            const files = yield readdirAsync(dir);
            for (const fileName of files) {
                if (fileName.endsWith('.map')) {
                    const filePath = path_1.default.join(this.getPath(dir), fileName);
                    yield this.uploadFile({ mapURL: fileName, filePath: filePath, app_id, host, env, release, appSecret, appKey });
                }
            }
        });
    }
    static uploadFile({ filePath, mapURL, app_id, host, release, env, appSecret, appKey, }) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            const Timestamp = `${Date.now()}`;
            const md5Token = new md5_1.Md5().appendStr(Timestamp).appendStr(appSecret).end().toString();
            const URL = `https://${host}${URI}`;
            try {
                const headers = {
                    'Content-Type': 'application/json',
                    'X-OpenApi-Timestamp': Timestamp,
                    'X-OpenApi-AppID': appKey,
                    'x-app-ids': app_id,
                    'X-OpenApi-Token': md5Token,
                };
                const body = JSON.stringify({
                    common: {
                        aid: Number(app_id),
                        site_type: 'web',
                        env,
                    },
                    js_filename: mapURL,
                    sourcemap: fs_1.default.readFileSync(filePath).toString(),
                    release,
                });
                const res = yield axios_1.default.post(URL, body, {
                    headers,
                    maxBodyLength: Infinity,
                    maxContentLength: Infinity,
                });
                const json = yield res.data;
                if (json.error_no !== 0) {
                    consoleReporter.error(json.error_msg || json.err_detail);
                    return;
                }
                consoleReporter.info(`upload sourcemap file ${mapURL} success`);
            }
            catch (e) {
                consoleReporter.error(e);
                return;
            }
        });
    }
    execute() {
        return this.uploadDirs();
    }
    uploadDirs() {
        var _a, _b, _c;
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            return UploadSourcemapsCommand.upload({
                paths: this._paths,
                app_id: this.app_id,
                host: (_a = this.host) !== null && _a !== void 0 ? _a : HOST,
                release: (_b = this.release) !== null && _b !== void 0 ? _b : DEFAULT_RELEASE,
                env: (_c = this.env) !== null && _c !== void 0 ? _c : DEFAULT_ENV,
                appSecret: this.appSecret,
                appKey: this.appKey,
            });
        });
    }
}
exports.UploadSourcemapsCommand = UploadSourcemapsCommand;
UploadSourcemapsCommand.paths = [clipanion_1.Command.Default];
//# sourceMappingURL=upload-sourcemaps.js.map